/* This file was generated by utilMakeHelp.c */



extern  void    HelpAdd();



void HTInit()
{
    HelpAdd( "add", "\
\n\
    add a b\n\
\n\
      UNIT/RESIDUE/ATOM          _a_\n\
      UNIT/RESIDUE/ATOM          _b_\n\
\n\
Add the object _b_ to the object _a_.   This command is used to place\n\
ATOMs within RESIDUEs, and RESIDUEs within UNITs.\n\
\n\
\n" );
    HelpAdd( "addAtomTypes", "\
\n\
    addAtomTypes {\n\
        { \"H\"   \"H\" \"sp3\" }\n\
        { \"HO\"  \"H\" \"sp3\" }\n\
        ...\n\
    }\n\
Add mapping of AMBER atom type to element and hybridization. Typically in\n\
leaprc.\n\
\n" );
    HelpAdd( "addIons", "\
    addIons unit ion1 #ion1 [ion2 #ion2]\n\
      UNIT                      _unit_\n\
      UNIT                      _ion1_\n\
      NUMBER                    _#ion1_\n\
      UNIT                      _ion2_\n\
      NUMBER                    _#ion2_\n\
Adds counterions in a shell around _unit_ using a Coulombic potential\n\
on a grid. If _#ion1_ is 0, the _unit_ is neutralized (_ion1_ must be\n\
opposite in charge to _unit_, and _ion2_ cannot be specified). Otherwise,\n\
the specified numbers of _ion1_ [_ion2_] are added [in alternating order].\n\
If solvent is present, it is ignored in the charge and steric calculations,\n\
and if an ion has a steric conflict with a solvent molecule, the ion is\n\
moved to the center of said molecule, and the latter is deleted. (To\n\
avoid this behavior, either solvate _after_ addIons, or use addIons2.)\n\
Ions must be monoatomic. Note that the one-at-a-time procedure is not\n\
guaranteed to globally minimize the electrostatic energy. When neutralizing\n\
regular-backbone nucleic acids, the first cations will generally be added\n\
between phosphates, leaving the final two ions to be placed somewhere around\n\
the middle of the molecule.\n\
The default grid resolution is 1 Angstrom, extending from an inner radius\n\
of (max ion size + max solute atom size) to an outer radius 4 Angstroms\n\
beyond. A distance-dependent dielectric is used for speed.\n\
\n" );
    HelpAdd( "addIons2", "\
    addIons2 unit ion1 #ion1 [ion2 #ion2]\n\
        UNIT                    _unit_\n\
        UNIT                    _ion1_\n\
        NUMBER                  _#ion1_\n\
        UNIT                    _ion2_\n\
        NUMBER                  _#ion2_\n\
Same as addIons, except solvent and solute are treated the same.\n\
\n" );
    HelpAdd( "addIonsRand", "\
\n\
    addIonsRand unit ion1 #ion1 [ion2 #ion2] [separation]\n\
\n\
        UNIT      _unit_\n\
        UNIT      _ion1_\n\
        NUMBER    _#ion1_\n\
        UNIT      _ion2_\n\
        NUMBER    _#ion2_\n\
        NUMBER    _separation_\n\
\n\
Adds counterions in a shell around _unit_ by replacing random solvent\n\
molecules. If _#ion1_ is 0, the _unit_ is neutralized (_ion1_ must be\n\
opposite in charge to _unit_, and _ion2_ cannot be specified). Otherwise,\n\
the specified numbers of _ion1_ [_ion2_] are added [in alternating order].\n\
If _separation_ is specified, ions will be guaranteed to be more than that\n\
distance apart in Angstroms.\n\
\n\
Ions must be monoatomic. This procedure is much faster than addIons, as\n\
it does not calculate charges. Solvent must be present. It must be possible\n\
to position the requested number of ions with the given separation in the\n\
solvent.\n\
\n\
\n" );
    HelpAdd( "addPath", "\
\n\
    addPath path\n\
\n\
      STRING                       _path_\n\
\n\
Add the directory in _path_ to the list of directories that are searched\n\
for files specified by other commands.\n\
\n\
\n" );
    HelpAdd( "restrainAngle", "\
\n\
    restrainAngle unit a b c force angle\n\
\n\
      UNIT                         _unit_\n\
      ATOM                         _a_\n\
      ATOM                         _b_\n\
      ATOM                         _c_\n\
      NUMBER                       _force_\n\
      NUMBER                       _angle_\n\
\n\
Add an angle restraint to _unit_ between atoms _a_, _b_, and _c_,\n\
having force constant of _force_, and equilibrium angle _angle_.\n\
\n\
\n" );
    HelpAdd( "restrainBond", "\
\n\
    restrainBond unit a b force length\n\
\n\
      UNIT                         _unit_\n\
      ATOM                         _a_\n\
      ATOM                         _b_\n\
      NUMBER                       _force_\n\
      NUMBER                       _length_\n\
\n\
Add a bond (distance) restraint to _unit_ between atoms _a_ and _b_\n\
with a force constant of _force_ and an equilibrium distance of _length_.\n\
\n\
\n" );
    HelpAdd( "restrainTorsion", "\
\n\
    restrainTorsion unit a b c d force phi multiplicity\n\
\n\
      UNIT                         _unit_\n\
      ATOM                         _a_\n\
      ATOM                         _b_\n\
      ATOM                         _c_\n\
      ATOM                         _d_\n\
      NUMBER                       _force_\n\
      NUMBER                       _phi_\n\
      NUMBER                       _multiplicity_\n\
\n\
Add a torsion restraint to _unit_ between atoms _a_, _b_, _c_, and\n\
_d_, with a force constant of _force_, an equilibrium torsion angle\n\
of _phi_, and a multiplicity of _multiplicity_.\n\
\n\
\n" );
    HelpAdd( "alias", "\
alias [alias[ string]]\n\
      STRING                    _alias_\n\
      STRING                    _string_\n\
\n\
alias string1 command - equivalence string1 to command.\n\
alias string1         - delete the alias for string1.\n\
alias                 - report all current aliases.\n\
\n" );
    HelpAdd( "alignAxes", "\
\n\
    alignAxes unit\n\
\n\
      UNIT                         _unit_\n\
\n\
Translate the geometric center of _unit_ to the origin and align\n\
the principle axes of the ATOMs within _unit_ along the coordinate\n\
axes.  This is done by calculating the moment of inertia of the UNIT\n\
using unit mass for each ATOM, and then diagonalizing the resulting\n\
matrix and aligning the eigenvectors along the coordinate axes.\n\
This command modifies the coordinates of the UNIT. It may be\n\
especially useful for preparing long solutes such as nucleic acids\n\
for solvation.\n\
\n\
\n" );
    HelpAdd( "loadAmberParams", "\
\n\
    variable = loadAmberParams filename\n\
      PARMSET                      _variable_\n\
      STRING                       _filename_\n\
\n\
Load an AMBER format parameter set file and place it in _variable_.\n\
All interactions defined in the parameter set will be contained within\n\
_variable_.   This command causes the loaded parameter set to be included\n\
in LEaP's list of parameter sets that are searched when parameters are\n\
required.  General proper and improper torsion parameters are modified,\n\
the AMBER general type \"X\" is replaced with the LEaP general type \"?\".\n\
\n\
\n" );
    HelpAdd( "bond", "\
\n\
    bond atom1 atom2 [ order ]\n\
\n\
      ATOM                         _atom1_\n\
      ATOM                         _atom2_\n\
      STRING                       _order_\n\
\n\
Create a bond between _atom1_ and _atom2_.  Both of these ATOMs must\n\
be contained by the same UNIT. By default, the bond will be a single\n\
bond.  By specifying \"S\", \"D\", \"T\", or \"A\" as the optional argument\n\
_order_ the user can specify a single, double, triple, or aromatic\n\
bond.\n\
\n\
\n" );
    HelpAdd( "center", "\
\n\
    center container\n\
      UNIT/RESIDUE/ATOM          _container_\n\
\n\
Display the coordinates of the geometric center of the ATOMs within\n\
_container_.\n\
\n\
\n" );
    HelpAdd( "charge", "\
\n\
    charge container\n\
\n\
      UNIT/RESIDUE/ATOM          _container_\n\
\n\
This command calculates the total charge of the ATOMs within _container_.\n\
The unperturbed and perturbed total charge are displayed.\n\
\n\
\n" );
    HelpAdd( "check", "\
\n\
    check unit [ parmset ]\n\
      UNIT                      _unit_\n\
      PARMSET/STRING            _parmset_\n\
\n\
This command can be used to check the UNIT for internal inconsistencies\n\
that could cause problems when performing calculations.  This is\n\
a very useful command that should be used before a UNIT is saved\n\
with saveAmberParm or its variations.\n\
With the optional parmset, all missing parameters are placed in the\n\
PARMSET to allow for easy editing of those parameters.  If a string is\n\
passed, a PARMSET will be created with that name.\n\
Currently it checks for the following possible problems:\n\
\n\
   - Long bonds.\n\
\n\
   - Short bonds.\n\
\n\
   - Non-integral total charge of the UNIT.\n\
\n\
   - Missing types.\n\
\n\
   - Close contacts between non-bonded ATOMs.  A close contact is\n\
     less than 1.5 angstroms.\n\
\n\
\n" );
    HelpAdd( "clearVariables", "\
\n\
    clearVariables [ list ]\n\
\n\
      LIST                         _list_\n\
\n\
This command removes variables from LEaP. If the _list_ argument\n\
is provided, then only the variables in the LIST will be removed.\n\
If no argument is provided then ALL variables will be removed.\n\
\n\
\n" );
    HelpAdd( "combine", "\
\n\
    variable = combine list\n\
      object                       _variable_\n\
      LIST                         _list_\n\
\n\
Combine the contents of the UNITs within _list_ into a single UNIT.\n\
The new UNIT is placed in _variable_.   This command is similar to\n\
the sequence command except it does not link the ATOMs of the UNITs\n\
together.\n\
\n\
\n" );
    HelpAdd( "copy", "\
\n\
    newvariable = copy variable\n\
\n\
      object                       _newvariable_\n\
      object                       _variable_\n\
\n\
Create an exact duplicate of the object _variable_. Changing the object\n\
_variable_ will not affect the object _newvariable_.\n\
This is in contrast to the situation created by \"newvariable = variable\"\n\
in which both names reference the same object.\n\
\n\
\n" );
    HelpAdd( "crossLink", "\
\n\
    crossLink res1 conn1 res2 conn2\n\
\n\
      RESIDUE                      _res1_\n\
      STRING                       _connect1_\n\
      RESIDUE                      _res2_\n\
      STRING                       _connect2_\n\
\n\
Create a bond between ATOMs at the connection point specified by\n\
_conn1_ and _conn2_.   The argument _conn1_ and _conn2_ can have the\n\
following values:\n\
\n\
Name_           Alternatives__\n\
$connect0      $nend, $firstend\n\
$connect1      $cend, $lastend\n\
$connect2      $send, $disulphide\n\
$connect3\n\
$connect4\n\
$connect5\n\
\n\
\n" );
    HelpAdd( "deSelect", "\
\n\
    deSelect obj\n\
\n\
      UNIT/RESIDUE/ATOM          _obj_\n\
\n\
Clears the SELECT flag on all ATOMs within _obj_.  See the select command.\n\
\n" );
    HelpAdd( "debugOff", "\
\n\
    debugOff filename\n\
\n\
      STRING                       _filename_\n\
\n\
This command is a system debugging function.  It turns off debugging\n\
messages from the source (.c) file _filename_.   The symbol *\n\
matches all files.  The default for all filenames is `off'.\n\
Note that system debugging is in effect only if LEaP was compiled\n\
with the preprocessor macro DEBUG defined.\n\
\n" );
    HelpAdd( "debugOn", "\
\n\
    debugOn filename\n\
\n\
      STRING                       _filename_\n\
\n\
This command is a system debugging function.  It turns on debugging\n\
messages from the source (.c) file _filename_.   The symbol *\n\
matches all files.  The default for all filenames is `off'.\n\
Note that system debugging is in effect only if LEaP was compiled\n\
with the preprocessor macro DEBUG defined.\n\
\n\
\n" );
    HelpAdd( "debugStatus", "\
\n\
    debugStatus\n\
This command is a memory debugging function.  It displays various\n\
messages that describe LEaP's usage of system resources.\n\
Note that memory debugging is in effect only if LEaP was compiled\n\
with the preprocessor macro MEMORY_DEBUG defined; MEMORY_DEBUG values\n\
range from 1 through 4 with the greatest being the most aggressive.\n\
\n\
\n" );
    HelpAdd( "desc", "\
\n\
    desc variable\n\
      object                       _variable_\n\
\n\
Print a description of the object.\n\
\n\
\n" );
    HelpAdd( "bondByDistance", "\
\n\
    bondByDistance container [ maxBond ]\n\
\n\
      UNIT/RESIDUE/ATOM         _container_\n\
      NUMBER                    _maxBond_\n\
\n\
Create single bonds between all ATOMs in _container_ that are within\n\
_maxBond_ angstroms of each other.   If _maxBond_ is not specified,\n\
a default distance of 2 angstroms used.\n\
\n" );
    HelpAdd( "edit", "\
\n\
    edit unit-parmset\n\
      UNIT/PARMSET              _unit-parmset_\n\
\n\
In xLEaP this command creates a unit editor or parameter set editor\n\
that contains the UNIT or PARMSET _unit-parmset_.   The user can view\n\
and edit the contents of the UNIT or PARMSET by using the mouse.\n\
If _unit-parmset_ is a PARMSET, then the user may select the Atom, Bond,\n\
Angle, Torsion, Improper Torsion, or Hydrogen Bond Parameters to\n\
edit by selecting the appropriate button.\n\
In tLEaP this command prints an error message.\n\
\n\
\n" );
    HelpAdd( "groupSelectedAtoms", "\
\n\
    groupSelectedAtoms unit name\n\
\n\
      UNIT                         _unit_\n\
      STRING                       _name_\n\
\n\
Create a group within _unit_ with the name _name_ using all of the\n\
ATOMs within the UNIT that are selected.  If the group has already\n\
been defined then overwrite the old group.\n\
\n\
\n" );
    HelpAdd( "help", "\
\n\
    help [string]\n\
\n\
      STRING                       _string_\n\
\n\
This command prints a description of the command in _string_.  If\n\
the STRING is not given then a list of legal STRINGs is provided.\n\
\n\
\n" );
    HelpAdd( "impose", "\
\n\
    impose unit seqlist internals\n\
\n\
      UNIT                         _unit_\n\
      LIST                         _seqlist_\n\
      LIST                         _internals_\n\
\n\
The impose command allows the user to impose internal coordinates\n\
on the UNIT. The list of RESIDUEs to impose the internal coordinates\n\
upon is in _seqlist_.  The internal coordinates to impose are in\n\
the LIST _internals_.\n\
The command works by looking into each RESIDUE within the UNIT that\n\
is listed in the _seqlist_ argument and attempts to apply each of\n\
the internal coordinates within _internals_.  The _seqlist_ argument\n\
is a LIST of NUMBERs that represent sequence numbers or ranges of\n\
sequence numbers.  Ranges of sequence numbers are represented by\n\
two-element LISTs that contain the first and last sequence number\n\
in the range.  The user can specify sequence number ranges that are\n\
larger than what is found in the UNIT. For example the range { 1 999 }\n\
represents all RESIDUEs in a 200 RESIDUE UNIT.\n\
The _internals_ argument is a LIST of LISTs.  Each sublist contains\n\
a sequence of ATOM names which are of type STRING followed by the\n\
value of the internal coordinate.  See the output of help _types_ for\n\
details on specifying STRINGs.  Examples of the impose command are:\n\
\n\
impose peptide { 1 2 3 } { { $N $CA  $C $N -40.0 } { $C $N  $CA $C\n\
-60.0 } }\n\
\n\
The RESIDUEs with sequence numbers 1, 2, and 5 within the UNIT peptide\n\
will assume an alpha helix conformation.\n\
\n\
impose peptide { 1 2  { 5 10 } 12 }  { { \"CA\" \"CB\" 5.0 } }\n\
\n\
This will impose on the residues with sequence numbers 1, 2, 5, 6,\n\
7, 8, 9, 10, and 12 within the UNIT peptide a bond length of 5.0\n\
angstroms between the alpha and beta carbons.  RESIDUEs without an\n\
ATOM named $CB (like glycine)  will be unaffected.\n\
Three types of conformational change are supported; bond length changes,\n\
bond angle changes, and torsion angle changes.  If the conformational\n\
change involves a torsion angle, then all dihedrals around the central\n\
pair of atoms are rotated.   The entire list of internals are applied\n\
to each RESIDUE.\n\
\n" );
    HelpAdd( "list", "\
    list\n\
List all of the variables currently defined.\n\
\n" );
    HelpAdd( "loadOff", "\
    loadOff filename\n\
      STRING                       _filename_\n\
\n\
This command loads the Object File Format library within the file named\n\
_filename_.  All UNITs and PARMSETs within the library will be loaded.\n\
The objects are loaded into LEaP under the variable names the objects\n\
had when they were saved.  Variables already in existence that have the\n\
same names as the objects being loaded will be overwritten.  PARMSETs\n\
loaded using this command are included in LEaP's library of PARMSETs\n\
that is searched whenever parameters are required.\n\
\n\
\n" );
    HelpAdd( "loadAmberPrep", "\
\n\
    loadAmberPrep filename [ prefix ]\n\
\n\
      STRING                       _filename_\n\
      STRING                       _prefix_\n\
\n\
This command loads an AMBER PREP input file.  For each residue that\n\
is loaded, a new UNIT is constructed that contains a single RESIDUE\n\
and a variable is created with the same name as the name of the residue\n\
within the PREP file.   If the optional argument _prefix_ is provided\n\
it will be prefixed to each variable name; this feature is used to\n\
prefix united atom residues, which have the same names as all-atom\n\
residues, with the string $U to distinguish them.\n\
\n\
\n" );
    HelpAdd( "loadMol2", "\
\n\
    variable = loadMol2 filename\n\
      STRING                       _filename_\n\
\n\
Load a Sybyl Mol2-format file with the file name _filename_.  The UNIT\n\
loaded will have the name specified for the MOLECULE in the input file.\n\
\n\
\n" );
    HelpAdd( "loadMol3", "\
\n\
    variable = loadMol3 filename\n\
      STRING                       _filename_\n\
\n\
Load a Sybyl-derived Mol3-format file with the file name _filename_.\n\
The UNIT loaded will have the name specified for the MOLECULE in the\n\
input file.\n\
\n\
More information:\n\
http://q4md-forcefieldtools.org/Tutorial/leap-mol3.php\n\
\n\
\n" );
    HelpAdd( "loadPdb", "\
\n\
    variable = loadPdb filename\n\
      STRING                       _filename_\n\
\n\
Load a Protein Databank format file with the file name _filename_.\n\
The sequence numbers of the RESIDUEs will be determined from the\n\
order of residues within the PDB file ATOM records.  For each\n\
residue in the PDB file, LEaP searches the variables currently\n\
defined for variable names that match the residue name.  If a\n\
match is found, then the contents of the variable are copied into\n\
the UNIT created for the PDB structure.  If no PDB `TER' card\n\
separates the current residue from the previous one, a bond is\n\
created between the connect1 ATOM of the previous residue and the\n\
connect0 atom of the new one.  As atoms are read from the ATOM\n\
records, their coordinates are written into the correspondingly\n\
named ATOMs within the residue being built.  If the entire residue\n\
is read and it is found that ATOM coordinates are missing, then\n\
external coordinates are built from the internal coordinates that\n\
were defined in the matching UNIT (residue) variable.  This allows\n\
LEaP to build coordinates for hydrogens and lone pairs which are not\n\
specified in PDB files.\n\
\n\
\n" );
    HelpAdd( "loadPdbUsingSeq", "\
\n\
    loadPdbUsingSeq filename unitlist\n\
\n\
      STRING                       _filename_\n\
      LIST                         _unitlist_\n\
\n\
This command reads a Protein Data Bank format file from the file\n\
named _filename_.  This command is identical to loadPdb except it\n\
does not use the residue names within the PDB file.   Instead, the\n\
sequence is defined by the user in _unitlist_.  For more details\n\
see loadPdb.\n\
\n\
\n" );
    HelpAdd( "logFile", "\
\n\
    logFile filename\n\
\n\
      STRING                       _filename_\n\
\n\
This command opens the file with the file name _filename_ as a log\n\
file.  User input and ALL output is written to the log file.  Output\n\
is written to the log file as if the verbosity level were set to 2.\n\
\n\
\n" );
    HelpAdd( "createAtom", "\
\n\
    variable = createAtom name type charge\n\
\n\
      ATOM                         _variable_\n\
      STRING                       _name_\n\
      STRING                       _type_\n\
      NUMBER                       _charge_\n\
\n\
Return a new ATOM with _name_, _type_, and _charge_.\n\
\n\
\n" );
    HelpAdd( "createResidue", "\
\n\
    variable = createResidue name\n\
      RESIDUE                      _variable_\n\
      STRING                       _name_\n\
\n\
Return a new and empty RESIDUE with the name _name_.\n\
\n\
\n" );
    HelpAdd( "createUnit", "\
\n\
    variable = createUnit name\n\
      UNIT                         _variable_\n\
      STRING                       _name_\n\
\n\
Return a new and empty UNIT with the name _name_.\n\
\n\
\n" );
    HelpAdd( "createParmset", "\
\n\
    variable = createParmset name\n\
      PARMSET                   _variable_\n\
      STRING                    _name_\n\
\n\
Return a new and empty PARMSET with the name _name_.\n\
\n\
\n" );
    HelpAdd( "quit", "\
\n\
    quit\n\
Quit LEaP.\n\
\n\
\n" );
    HelpAdd( "remove", "\
\n\
    remove a b\n\
\n\
      UNIT/RESIDUE/ATOM          _a_\n\
      UNIT/RESIDUE/ATOM          _b_\n\
\n\
Remove the object _b_ from the object _a_.   If _a_ is not contained\n\
by _b_ then an error message will be displayed.  This command is\n\
used to remove ATOMs from RESIDUEs, and RESIDUEs from UNITs.   If\n\
the object represented by _b_ is not referenced by some variable\n\
name then it will be destroyed.\n\
\n\
\n" );
    HelpAdd( "deleteBond", "\
\n\
    deleteBond atom1 atom2\n\
\n\
      ATOM                         _atom1_\n\
      ATOM                         _atom2_\n\
\n\
Remove the bond between the ATOMs _atom1_ and _atom2_.   If no bond\n\
exists, an error will be displayed.\n\
\n\
\n" );
    HelpAdd( "deleteRestraint", "\
\n\
    deleteRestraint unit a b [c [d]]\n\
\n\
      UNIT                         _unit_\n\
      ATOM                         _a_\n\
      ATOM                         _b_\n\
      ATOM                         _c_\n\
      ATOM                         _d_\n\
\n\
Remove a bond, angle, or torsion restraint from _unit_, depending\n\
on the number of ATOMs specified.\n\
\n\
\n" );
    HelpAdd( "saveOff", "\
\n\
    saveOff object filename\n\
\n\
      object                       _object_\n\
      STRING                       _filename_\n\
\n\
The saveOff command allows the user to save UNITs, and PARMSETs to a\n\
file named _filename_.  The file is written using the Object File\n\
Format (OFF) and can accommodate an unlimited number of uniquely\n\
named objects.  The names by which the objects are stored are the\n\
variable names specified in the argument of this command.  If the\n\
file _filename_ already exists then the new objects will be added\n\
to the file.  If there are objects within the file with the same\n\
names as objects being saved then the old objects will be overwritten.\n\
The argument _object_ can be a single UNIT, a single PARMSET, or\n\
a LIST of mixed UNITs and PARMSETs.\n\
\n\
\n" );
    HelpAdd( "saveAmberParm", "\
\n\
    saveAmberParm     unit topologyfilename coordinatefilename\n\
\n\
      UNIT                         _unit_\n\
      STRING                       _topologyfilename_\n\
      STRING                       _coordinatefilename_\n\
\n\
Save the AMBER topology and coordinate files for the UNIT into the\n\
files named _topologyfilename_ and _coordinatefilename_ respectively.\n\
This command will cause LEaP to search its list of PARMSETs for\n\
parameters defining all of the interactions between the ATOMs within\n\
the UNIT.  This command produces a topology file and a coordinate file\n\
which are identical in format to those produced by the AMBER program\n\
PARM, and which can be read into AMBER and SPASMS for energy minimization,\n\
dynamics, or nmode calculations.\n\
See also: saveAmberParmPol, saveAmberParmPert, and saveAmberParmPolPert\n\
for including atomic polarizabilities and preparing free energy\n\
perturbation calculations and saveAmberParmNetcdf for saving in a\n\
binary format.\n\
\n\
\n" );
    HelpAdd( "saveAmberParmNetcdf", "\
\n\
saveAmberParmNetcdf     unit topologyfilename coordinatefilename\n\
\n\
UNIT                         _unit_\n\
STRING                       _topologyfilename_\n\
STRING                       _coordinatefilename_\n\
\n\
Save the AMBER topology and coordinate files for the UNIT into the\n\
files named _topologyfilename_ and _coordinatefilename_ respectively.\n\
This command will cause LEaP to search its list of PARMSETs for\n\
parameters defining all of the interactions between the ATOMs within\n\
the UNIT.  This command produces a topology file and a coordinate file\n\
which can be read into AMBER and SPASMS for energy minimization, dynamics,\n\
or nmode calculations.\n\
The coordinate file written will be in the binary NetCDF AMBER restart\n\
format, which enables the writing of larger input files and quicker I/O.\n\
Use saveAmberParm for the regular ASCII coordinate format.\n\
\n\
\n" );
    HelpAdd( "saveAmberParmPol", "\
\n\
    saveAmberParmPol unit topologyfilename coordinatefilename\n\
\n\
Like saveAmberParm, but includes atomic polarizabilities in the topology\n\
file for use with IPOL=1 in Sander. The polarizabilities are according\n\
to atom type, and are defined in the 'mass' section of the parm.dat or\n\
frcmod file. Note: charges are normally scaled when polarizabilities are\n\
used - see scaleCharges for an easy way of doing this.\n\
\n\
\n" );
    HelpAdd( "saveAmberParmPert", "\
\n\
    saveAmberParmPert unit topologyfilename coordinatefilename\n\
\n\
      UNIT                         _unit_\n\
      STRING                       _topologyfilename_\n\
      STRING                       _coordinatefilename_\n\
\n\
Save the AMBER topology and coordinate files for the UNIT into the\n\
files named _topologyfilename_ and _coordinatefilename_ respectively.\n\
This command will cause LEaP to search its list of PARMSETs for\n\
parameters defining all of the interactions between the ATOMs within\n\
the UNIT - including the perturbed ATOMs (which are ignored by the\n\
vanilla saveAmberParm command).  This command produces a topology file\n\
and a coordinate file that are identical in format to those produced by\n\
the AMBER PARM program using the PERT option, and which can be read into\n\
AMBER and SPASMS for free energy calculations.\n\
\n\
\n" );
    HelpAdd( "saveAmberParmPolPert", "\
\n\
    saveAmberParmPolPert unit topologyfilename coordinatefilename\n\
\n\
Like saveAmberParmPert, but includes atomic polarizabilities in the topology\n\
file for use with IPOL=1 in Gibbs. The polarizabilities are according to\n\
atom type, and are defined in the 'mass' section of the parm.dat or frcmod\n\
file. Note: charges are normally scaled when polarizabilities are used -\n\
see scaleCharges for an easy way of doing this.\n\
\n\
\n" );
    HelpAdd( "saveAmberPrep", "\
\n\
    saveAmberPrep unit filename\n\
\n\
      UNIT                         _unit_\n\
      STRING                       _filename_\n\
\n\
Save all residues in the UNIT to a prep.in file. All possible improper\n\
dihedrals are given for each residue, so unwanted ones need to be\n\
deleted from the file. 'Connect0' and 'connect1' atoms must be defined\n\
for each residue.\n\
\n\
\n" );
    HelpAdd( "saveOffParm", "\
\n\
    This command is obsolete.\n\
\n\
\n" );
    HelpAdd( "addPdbAtomMap", "\
\n\
    addPdbAtomMap list\n\
      LIST                         _list_\n\
\n\
The atom Name Map is used to try to map atom names read from PDB files\n\
to atoms within residue UNITs when the atom name in the PDB file does\n\
not match an atom in the residue.  This enables PDB files to be read\n\
in without extensive editing of atom names.  The LIST is a LIST of LISTs:\n\
      { {sublist} {sublist} ... }\n\
where each sublist is of the form\n\
      { \"OddAtomName\" \"LibAtomName\" }\n\
Many `odd' atom names can map to one `standard' atom name, but any single\n\
odd atom name maps only to the last standard atom name it was mapped to.\n\
\n" );
    HelpAdd( "addPdbResMap", "\
\n\
    addPdbResMap list\n\
      LIST                         _list_\n\
\n\
The Name Map is used to map residue names read from PDB files to variable\n\
names within LEaP.  The LIST is a LIST of LISTs:\n\
      { {sublist} {sublist} ... }\n\
Each sublist contains two or three entries to add to the Name Map:\n\
      { [terminalflag] PDBName LEaPVar }\n\
where the PDBName will be mapped to the LEaPVar. The terminalflag indicates\n\
the special cases of terminal residues: allowable values are 0 for beginning\n\
residues (N-terminal for proteins, 5' for nucleic acids) and 1 for ending\n\
residues (C-terminal for proteins, 3' for nucleic acids).  If the\n\
terminalflag is given, the PDBName->LEaPVar name map will only be applied\n\
for the appropriate terminal residue.  The `leaprc' file included with\n\
the distribution contains default mappings.\n\
\n\
\n" );
    HelpAdd( "clearPdbAtomMap", "\
\n\
    clearPdbAtomMap\n\
\n\
Clear the Name Map used for ``second-chance'' mapping of atom names in\n\
PDB files to atoms within residue UNITs.  See addPdbAtomMap.\n\
\n" );
    HelpAdd( "clearPdbResMap", "\
\n\
    clearPdbResMap\n\
\n\
Clear the Name Map used to map residue names in PDB files to variable\n\
names within LEaP.  See addPdbResMap.\n\
\n\
\n" );
    HelpAdd( "displayPdbAtomMap", "\
\n\
    displayPdbAtomMap\n\
\n\
Display the Name Map used for ``second chance'' mapping of atom names\n\
in PDB files to atoms within residue UNITs.  See addPdbAtomMap.\n\
\n\
\n" );
    HelpAdd( "displayPdbResMap", "\
\n\
    displayPdbResMap\n\
\n\
Display the Name Map used to map residue names in PDB files to variable\n\
names within LEaP.  See addPdbResMap.\n\
\n\
\n" );
    HelpAdd( "savePdb", "\
\n\
    savePdb unit filename\n\
\n\
      UNIT                         _unit_\n\
      STRING                       _filename_\n\
\n\
Write UNIT to the file _filename_ as a PDB format file.\n\
\n\
\n" );
    HelpAdd( "saveMol2", "\
\n\
    saveMol2 unit filename option\n\
\n\
      UNIT                         _unit_\n\
      STRING                       _filename_\n\
      NUMBER                       _option_\n\
\n\
Write UNIT to the file _filename_ as a Mol2 format file.\n\
option = 0 for Default atom types\n\
option = 1 for AMBER atom types\n\
\n\
More information:\n\
http://q4md-forcefieldtools.org/Tutorial/leap.php\n\
\n\
\n" );
    HelpAdd( "saveMol3", "\
\n\
    saveMol3 unit filename option\n\
\n\
      UNIT                         _unit_\n\
      STRING                       _filename_\n\
      NUMBER                       _option_\n\
\n\
Write UNIT to the file _filename_ as a Mol3 format file.\n\
option = 0 for Default atom types\n\
option = 1 for AMBER atom types\n\
\n\
More information:\n\
http://q4md-forcefieldtools.org/Tutorial/leap-mol3.php\n\
\n\
\n" );
    HelpAdd( "select", "\
\n\
    select obj\n\
\n\
      UNIT/RESIDUE/ATOM          _obj_\n\
\n\
Sets the SELECT flag on all ATOMs within _obj_.  See the deSelect command.\n\
\n\
\n" );
    HelpAdd( "sequence", "\
\n\
    variable = sequence list\n\
\n\
      LIST                         _list_\n\
\n\
The sequence command is used to create a new UNIT by copying the\n\
contents of a LIST of UNITs.  As each UNIT in the list is copied,\n\
a bond is created between its head atom and the tail ATOM of the\n\
previous UNIT, if both connect ATOMs are defined.  If only one of\n\
the connect pair is defined, a warning is generated and no bond is\n\
created.  If neither connection ATOM is defined then no bond is\n\
created.  As each RESIDUE within a UNIT is copied, it is assigned a\n\
sequence number reflecting the order added.  The order of RESIDUEs\n\
in multi-RESIDUE UNITs is maintained.\n\
This command builds reasonable starting coordinates for the new UNIT\n\
by assigning internal coordinates to the linkages between the component\n\
UNITs and building the Cartesian coordinates from these and the\n\
internal coordinates of the component UNITs.\n\
\n\
\n" );
    HelpAdd( "scaleCharges", "\
\n\
    scaleCharges container scale_factor\n\
\n\
      UNIT/RESIDUE/ATOM   _container_\n\
      NUMBER              _scale_factor_\n\
\n\
This command scales the charges in the object by _scale_factor_,\n\
which must be > 0.  It is useful for building systems for use\n\
with polarizable atoms, e.g.\n\
> x = copy solute\n\
> scaleCharges x 0.8\n\
> y = copy WATBOX216\n\
> scalecharges y 0.875\n\
> solvatebox x y 10\n\
> saveamberparmpol x x.top x.crd\n\
\n" );
    HelpAdd( "set", "\
\n\
   set default variable value\n\
      STRING                       _variable_\n\
      STRING                       _value_\n\
OR\n\
    set container parameter object\n\
      UNIT/RESIDUE/ATOM/STRING     _container_\n\
      STRING                       _parameter_\n\
      object                       _object/value_\n\
\n\
This command sets the values of some global parameters (when the first\n\
argument is \"default\") or sets various parameters associated with _container_.\n\
\n\
To see the possible variables for \"set default\", type \"help set_default\".\n\
\n\
The box parameter of a UNIT defines the bounding box of the UNIT; this is\n\
not a UNIT's periodic box.  The setBox and solvate family of commands add a\n\
periodic box to a UNIT; for a description, type, e.g., \"help setBox\".\n\
\n\
The more useful parameters for each type of _container_ are the following:\n\
  container    parameters           values\n\
\n\
  UNIT         name                 STRING\n\
               head, tail           ATOM [e.g. unit.1.1]\n\
               restype              \"protein\" \"nucleic\" \"saccharide\" \"solvent\"\n\
                                    \"undefined\" [sets all residues in UNIT]\n\
               box                  LIST [side lengths: {A B C}]\n\
                                    or NUMBER [cube side length] or \"null\"\n\
               cap                  LIST [center, radius: {X Y Z  R}]\n\
                                    or \"null\"\n\
\n\
  RESIDUE      name                 STRING\n\
  [e.g.        restype              [see UNIT]\n\
   unit.1]     connect0, connect1   ATOM [e.g. unit.1.1]\n\
               imagingAtom          ATOM [e.g. unit.1.1]\n\
\n\
  ATOM         name, pertName       STRING [<= 4 chars]\n\
  [e.g.        type, pertType       STRING [<= 2 chars]\n\
   unit.1.1]   element              STRING\n\
               pert                 \"true\" [or pert flag unset]\n\
               charge, pertCharge   DOUBLE\n\
               position             LIST [{X Y Z}]\n\
\n" );
    HelpAdd( "set_default", "\
Allowed arguments to \"set default variable value\" are these:\n\
  variables        values       descriptions\n\
\n\
  PdbWriteCharges  \"on\"         add charges to each ATOM record\n\
                   \"off\"        don't do this (default)\n\
\n\
  OldPrmtopFormat  \"on\"         use prmtop format from Amber6 and earlier\n\
                   \"off\"        use the new prmtop format (default)\n\
\n\
  Gibbs            \"on\"         require perturbed atoms to be set explicitly\n\
                                   (needed for gibbs)\n\
                   \"off\"        set perturbed if Type != PertType (default)\n\
                                   (OK for sander)\n\
\n\
  UseResIds        \"on\"         put cols 22-27 of the input pdb file into\n\
                   \"off\"        a RESIDUE_ID table in prmtop files; default\n\
                                is \"off\"; only works with new prmtop formats,\n\
                                and when a single loadPdb command is used to\n\
                                create a unit.\n\
\n\
  Charmm           \"on\"         include terms for CHARMM22 force fields\n\
                   \"off\"        don't include these (default)\n\
\n\
  DeleteExtraPointAngles\n\
                   \"on\"         delete angles and torsions relating to\n\
                                   extra points (default)\n\
                   \"off\"        don't delete these (for older codes only)\n\
\n\
  FlexibleWater    \"on\"         allow for flexible 3-point water models\n\
                   \"off\"        assume 3-point water models are rigid (default)\n\
\n\
  PBRadii          \"bondi\"      use Bondi radii for generalized Born\n\
                   \"mbondi\"     use H-modified Bondi radii (default)\n\
                   \"mbondi2\"    use H(N)-modified Bondi radii\n\
                   \"mbondi3\"    ArgH and AspGluO modified Bondi2 radii\n\
                   \"parse\"      Radii from the Sitkoff et al. parse parameters\n\
                   \"pbamber\"    Huo and Kollman optimized radii (old!)\n\
                   \"amber6\"     use radii that were the default in amber6\n\
                                   (only recommended for backwards compat.)\n\
\n\
  Dielectric       \"distance\"   use distance-dependent dielectric (default)\n\
                   \"constant\"   use constant dielectric\n\
\n\
  dipole_damp_factor    real    sets the default value for \"DIPOLE_DAMP_FACTOR\"\n\
                                for dipole screening factors in Thole models.\n\
                                Valid value > 0.0\n\
\n\
  sceescalefactor  real         sets the default value for \"SCEE_SCALE_FACTOR\"\n\
                                for 1-4 EEL scaling factors. Valid value > 0.0.\n\
                                Default=1.2.\n\
\n\
  scnbscalefactor  real         sets the default value for \"SCNB_SCALE_FACTOR\"\n\
                                for 1-4 NB scaling factors. Valid value > 0.0.\n\
                                Default=2.0.\n\
\n\
  CMAP             \"on\"         include CMAP corrections for dihedrals\n\
                   \"off\"        don't include these (default)\n\
\n\
  PHIPSIMAP        \"on\"         include residue-based PHIPSI parameters\n\
                   \"off\"        don't include these (default)\n\
\n\
  ipol             integer      Sets the default value for IPOL.\n\
                                Valid values are 0 - 4.\n\
                                Default value is 0, meaning disabled.\n\
\n\
  nocenter         \"on\"         coordinates will not be centered in the\n\
                                periodic simulation box\n\
                   \"off\"        coordinates will be centered (default)\n\
\n\
  reorder_residues \"on\"         solvent will be moved to the end (default)\n\
                   \"off\"        residue order will be maintained as input.\n\
                                Beta feature: use at your own risk!\n\
\n" );
    HelpAdd( "setBox", "\
\n\
    setBox solute enclosure [ buffer ]\n\
      UNIT                         _solute_\n\
      \"vdw\" OR \"centers\"           _enclosure_\n\
      object                       _buffer_\n\
\n\
The setBox command creates a periodic box around the _solute_ UNIT, turning\n\
it into a periodic system for the simulation programs.  It does not add\n\
any solvent to the system. The choice of \"vdw\" or \"centers\" determines\n\
whether the box encloses all entire atoms or just all atom centers -\n\
use \"centers\" if the system has been previously equilibrated as a\n\
periodic box. See the solvateBox command for a description of the\n\
buffer object, which extends either type of box by an arbitrary amount.\n\
\n\
\n" );
    HelpAdd( "showdefault", "\
\n\
    showDefault [ variable OR all OR * ]\n\
      STRING                       _variable_\n\
\n\
The showdefault command shows the values assigned to the variables by\n\
the \"set default\" command. Without variable, with \"all\", or with \"*\",\n\
all default variables are shown.\n\
\n\
\n" );
    HelpAdd( "solvateBox", "\
\n\
    solvateBox solute solvent buffer [ \"iso\" ] [ closeness ]\n\
\n\
      UNIT                         _solute_\n\
      UNIT                         _solvent_\n\
      object                       _buffer_\n\
      NUMBER                       _closeness_\n\
\n\
The solvateBox command creates a solvent box around the _solute_ UNIT.\n\
The _solute_ UNIT is modified by the addition of _solvent_ RESIDUEs.\n\
\n\
The user may want to first align long solutes that are not expected\n\
to tumble using alignAxes, in order to minimize box volume.\n\
\n\
The normal choice for a TIP3 _solvent_ UNIT is WATBOX216. Note that\n\
constant pressure equilibration is required to bring the artificial box\n\
to reasonable density, since Van der Waals voids remain due to the\n\
impossibility of natural packing of solvent around the solute and at\n\
the edges of the box.\n\
\n\
The solvent box UNIT is copied and repeated in all three spatial directions\n\
to create a box containing the entire solute and a buffer zone defined\n\
by the _buffer_ argument. The _buffer_ argument defines the distance,\n\
in angstroms, between the wall of the box and the closest ATOM in the\n\
solute.\n\
\n\
If the buffer argument is a single NUMBER, then the buffer distance is\n\
the same for the x, y, and z directions, unless the \"iso\" option is used\n\
to make the box isometric, with the shortest box clearance = buffer. If\n\
\"iso\" is used, the solute is rotated to orient the principal axes,\n\
otherwise it is just centered on the origin.\n\
\n\
If the buffer argument is a LIST of three NUMBERS, then the NUMBERs are\n\
applied to the x, y, and z axes respectively. As the larger box is created\n\
and superimposed on the solute, solvent molecules overlapping the solute\n\
are removed.\n\
\n\
The optional _closeness_ parameter can be used to control the extent to\n\
which _solvent_ ATOMs overlap _solute_ ATOMs.  The default value of\n\
the _closeness_ argument is 1.0, which allows no overlap.  Smaller\n\
values allow solvent ATOMs to overlap _solute_ ATOMs by (1 - closeness) *\n\
R*ij, where R*ij is the sum of the Van der Waals radii of solute and\n\
solvent atoms.  Values greater than 1 enforce a minimum gap between\n\
solvent and solute of (closeness - 1) * R*ij.\n\
\n\
This command modifies the _solute_ UNIT in several ways.  First, the\n\
coordinates of the ATOMs are modified to move the center of a box\n\
enclosing the Van der Waals radii of the atoms to the origin.  Secondly,\n\
the UNIT is modified by the addition of _solvent_ RESIDUEs copied from\n\
the _solvent_ UNIT. Finally, the box parameter of the new system (still\n\
named for the _solute_) is modified to reflect the fact that a periodic,\n\
rectilinear solvent box has been created around it.\n\
\n" );
    HelpAdd( "solvateOct", "\
\n\
    solvateOct solute solvent buffer [ \"iso\" ] [ closeness ]\n\
\n\
      UNIT                         _solute_\n\
      UNIT                         _solvent_\n\
      object                       _buffer_\n\
      NUMBER                       _closeness_\n\
\n\
The solvateOct command is the same as solvateBox, except the corners\n\
of the box are sliced off, resulting in a truncated octahedron, which\n\
typically gives a more uniform distribution of solvent around the\n\
solute.\n\
\n\
In solvateOct, when a LIST is given for the buffer argument, four\n\
numbers are given instead of three, where the fourth is the diagonal\n\
clearance. If 0.0 is given as the fourth number, the diagonal clearance\n\
resulting from the application of the x,y,z clearances is reported. If\n\
a non-0 value is given, this may require scaling up the other clearances,\n\
which is also reported. Similarly, if a single number is given, any\n\
scaleup of the x,y,z buffer to accommodate the diagonal clip is reported.\n\
\n\
If the \"iso\" option is used, the isometric truncated octahedron is\n\
rotated to an orientation used by the PME code, and the box and angle\n\
dimensions output by the saveAmberParm* commands are adjusted for PME\n\
code imaging.\n\
\n" );
    HelpAdd( "solvateCap", "\
\n\
    solvateCap solute solvent position radius [ closeness ]\n\
\n\
      UNIT                         _solute_\n\
      UNIT                         _solvent_\n\
      object                       _position_\n\
      NUMBER                       _radius_\n\
      NUMBER                       _closeness_\n\
\n\
The solvateCap command creates a solvent cap around the _solute_ UNIT\n\
or a part thereof.  The _solute_ UNIT is modified by the addition of\n\
_solvent_ RESIDUEs.\n\
The normal choice for a TIP3 _solvent_ UNIT is WATBOX216. The _solvent_\n\
box is repeated in all three spatial directions and _solvent_ RESIDUEs\n\
selected to create a solvent sphere with a radius of _radius_ Angstroms.\n\
\n\
The _position_ argument defines where the center of the solvent cap\n\
is to be placed.   If _position_ is a UNIT, RESIDUE, ATOM, or a LIST\n\
of UNITs, RESIDUEs, or ATOMs, then the geometric center of the ATOMs\n\
within the object will be used as the center of the solvent cap sphere.\n\
If _position_ is a LIST containing three NUMBERs then the _position_\n\
argument will be treated as a vector that defines the position of\n\
the solvent cap sphere center.\n\
\n\
The optional _closeness_ parameter can be used to control the extent to\n\
which _solvent_ ATOMs overlap _solute_ ATOMs.  The default value of\n\
the _closeness_ argument is 1.0, which allows no overlap.  Smaller\n\
values allow solvent ATOMs to overlap _solute_ ATOMs by (1 - closeness) *\n\
R*ij, where R*ij is the sum of the Van der Waals radii of solute and\n\
solvent atoms.  Values greater than 1 enforce a minimum gap between\n\
solvent and solute of (closeness - 1) * R*ij.\n\
\n\
This command modifies the _solute_ UNIT in several ways.  First,\n\
the UNIT is modified by the addition of _solvent_ RESIDUEs copied\n\
from the _solvent_ UNIT. Secondly, the cap parameter of the UNIT\n\
_solute_ is modified to reflect the fact that a solvent cap has been\n\
created around the solute.\n\
\n\
\n" );
    HelpAdd( "solvateDontClip", "\
\n\
    solvateDontClip solute solvent buffer [ closeness ]\n\
\n\
      UNIT                         _solute_\n\
      UNIT                         _solvent_\n\
      object                       _buffer_\n\
      NUMBER                       _closeness_\n\
\n\
This command is identical to the solvateBox command except that the\n\
solvent box that is created is not clipped to the boundary of the\n\
_buffer_ region.  This command forms larger solvent boxes than does\n\
solvateBox because it does not cause solvent that is outside the buffer\n\
region to be discarded.   This helps to preserve the periodic structure\n\
of properly constructed solvent boxes, preventing hot-spots from\n\
forming.\n\
\n\
\n" );
    HelpAdd( "solvateShell", "\
\n\
    solvateShell solute solvent thickness [ closeness ]\n\
\n\
      UNIT                         _solute_\n\
      UNIT                         _solvent_\n\
      NUMBER                       _thickness_\n\
      NUMBER                       _closeness_\n\
\n\
The solvateShell command creates a solvent shell around the _solute_ UNIT.\n\
The _solute_ UNIT is modified by the addition of _solvent_ RESIDUEs.\n\
\n\
The normal choice for a TIP3 _solvent_ UNIT is WATBOX216. The _solvent_ box\n\
is repeated in all three spatial directions and _solvent_ RESIDUEs selected\n\
to create a solvent shell with a radius of _thickness_ Angstroms around the\n\
_solute_.\n\
\n\
The _thickness_ argument defines the maximum distance a _solvent_ ATOM may\n\
be from the closest _solute_ ATOM.\n\
\n\
The optional _closeness_ parameter can be used to control overlap of _solvent_\n\
with _solute_ ATOMs.   The default value of the _closeness_ argument is\n\
1.0, which allows contact but no overlap.  Please see the solvateBox\n\
command for more details on the _closeness_ parameter.\n\
\n\
\n" );
    HelpAdd( "measureGeom", "\
\n\
    measureGeom atom1 atom2 [ atom3 atom4 ]\n\
      ATOM                _atom1_ _atom2_ _atom3_ _atom4_\n\
\n\
Measure the distance, angle or torsion between two, three or four ATOMs,\n\
respectively.\n\
\n\
\n" );
    HelpAdd( "listOff", "\
\n\
    listOff library\n\
      STRING                       _library_\n\
\n\
List the UNITs/PARMSETs stored within the Object File Format file\n\
named _library_.\n\
\n\
\n" );
    HelpAdd( "deleteOffLibEntry", "\
\n\
    deleteOffLibEntry library entry\n\
      STRING                       _library_\n\
      STRING                       _entry_\n\
\n\
Delete _entry_ from the Object File Format file named _library_.\n\
\n\
\n" );
    HelpAdd( "source", "\
\n\
    source filename\n\
      STRING                       _filename_\n\
\n\
This command executes LEaP commands within a text file.  To display the\n\
commands as they are read, see the verbosity command.  The text within\n\
the source file must be formatted exactly like the text the user types\n\
into LEaP.\n\
\n\
\n" );
    HelpAdd( "translate", "\
\n\
    translate atoms direction\n\
\n\
      UNIT/RESIDUE/ATOM            _atoms_\n\
      LIST                         _direction_\n\
\n\
Translate all of the ATOMs within _atoms_ by the vector defined by\n\
the three NUMBERs in the LIST _ direction_.\n\
\n\
\n" );
    HelpAdd( "transform", "\
\n\
    transform atoms matrix\n\
\n\
      CONTAINER/LIST               _atoms_\n\
      LIST                         _matrix_\n\
\n\
Translate all of the ATOMs within _atoms_ by the (3X3) or (4X4) matrix\n\
defined by the 9 or 16 NUMBERs in the LIST of LISTs _matrix_.\n\
    { { r11  r12  r13  -tx }\n\
      { r21  r22  r23  -ty }\n\
      { r31  r32  r33  -tz }\n\
      { 0    0    0     1  } }\n\
The diagonal upper left elements, rII can be used for symmetry operations,\n\
e.g. a reflection in the XY plane can be produced with r11=1, r22=1, r33=-1\n\
where the other rIJ elements are 0. The -t column is used to specify\n\
translations along the appropriate axes (0 for no translation).\n\
\n\
\n" );
    HelpAdd( "matchVariables", "\
\n\
    variable = matchVariables string\n\
\n\
      LIST                         _variable_\n\
      STRING                       _string_\n\
\n\
Create a LIST of variables with names that match _string_. The _string_\n\
argument can contain the wildcard characters \"?\" and \"*\" to match any\n\
single character or substring of characters, respectively.\n\
\n\
\n" );
    HelpAdd( "verbosity", "\
\n\
    verbosity level\n\
\n\
      NUMBER                       _level_\n\
\n\
This command sets the level of output that LEaP provides the user.\n\
A value of 0 is the default, providing the minimum of messages.  A\n\
value of 1 will produce more output, and a value of 2 will produce\n\
all of the output of level 1 and display the text of the script lines\n\
executed with the source command.\n\
\n\
\n" );
    HelpAdd( "zMatrix", "\
\n\
    zMatrix obj zmatrix\n\
\n\
      UNIT/RESIDUE/ATOM            _obj_\n\
      LIST                         _zmatrix_\n\
\n\
The zMatrix command is quite complicated.  It is used to define the\n\
external coordinates of ATOMs within _obj_ using internal coordinates.\n\
The second parameter of the zMatrix command is a LIST of LISTs; each\n\
sub-list has several arguments:\n\
\n\
{ a1 a2 bond12 }\n\
\n\
This entry defines the coordinate of _a1_ by placing it _bond12_ angstroms\n\
along the x-axis from ATOM _a2_.   If ATOM _a2_ does not have coordinates\n\
defined then ATOM _a2_ is placed at the origin.\n\
\n\
{ a1 a2 a3 bond12 angle123 }\n\
\n\
This entry defines the coordinate of _a1_ by placing it _bond12_ angstroms\n\
away from ATOM _a2_ making an angle of _angle123_ degrees between\n\
_a1_, _a2_ and _a3_.  The angle is measured in a right hand sense\n\
and in the x-y plane.   ATOMs _a2_ and _a3_ must have coordinates defined.\n\
\n\
{ a1 a2 a3 a4 bond12 angle123 torsion1234 }\n\
\n\
This entry defines the coordinate of _a1_ by placing it _bond12_ angstroms\n\
away from ATOM _a2_, creating an angle of _angle123_ degrees between\n\
_a1_, _a2_, and _a3_, and making a torsion angle of _torsion1234_ between\n\
_a1_, _a2_, _a3_, and _a4_.\n\
\n\
{ a1 a2 a3 a4 bond12 angle123 angle124 orientation }\n\
\n\
This entry defines the coordinate of _a1_ by placing it _bond12_ angstroms\n\
away from ATOM _a2_, making angles _angle123_ between ATOMs _a1_,\n\
_a2_, and _a3_, and _angle124_ between ATOMs _a1_, _a2_, and _a4_.  The\n\
argument _orientation_ defines whether the ATOM _a1_ is above or below\n\
a plane defined by the ATOMs _a2_, _a3_, and _a4_.  If _orientation_\n\
is positive then _a1_ will be placed in such a way so that the inner\n\
product of (_a3_-_a2_)  cross (_a4_-_a2_) with (_a1_-_a2_) is positive.\n\
Otherwise _a1_ will be placed on the other side of the plane.  This\n\
allows the coordinates of a molecule like fluoro-chloro-bromo-methane\n\
to be defined without having to resort to dummy atoms.\n\
The first arguments within the zMatrix entries ( _a1_, _a2_, _a3_,\n\
_a4_ ) are either ATOMs or STRINGs containing names of ATOMs within\n\
_obj_.   The subsequent arguments are all NUMBERs.   Any ATOM can be\n\
placed at the _a1_ position, even those that have coordinates defined.\n\
This feature can be used to provide an endless supply of dummy atoms,\n\
if they are required.   A predefined dummy atom with the name \"*\"\n\
(a single asterisk, no quotes)  can also be used.\n\
No order is imposed in the sub-lists.  The user can place sub-lists\n\
in arbitrary order, as long as they maintain the requirement that\n\
all atoms _a2_, _a3_, and _a4_ must have external coordinates defined,\n\
except for entries that define the coordinate of an ATOM using only\n\
a bond length.\n\
\n\
\n" );
    HelpAdd( "_types_", "\
    UNIT      A collection of ATOMs, perhaps grouped into one or more\n\
                RESIDUEs.  In combination with PARMSET parameters, a UNIT\n\
                contains all the information needed for a simulation.\n\
    RESIDUE   A collection of ATOMs, some of which may be designated\n\
                as \"connect\"ing. A RESIDUE has a chemical type such as\n\
                \"protein,\" \"nucleic,\" \"saccharide,\" \"solvent,\" or\n\
                \"undefined.\"\n\
    ATOM      Has a name, a force field type, an element type, a charge,\n\
                perturbed name-types-charge, and a position.\n\
    PARMSET   A collection of force field parameters. When a UNIT is\n\
                associated with parameters, the PARMSETs that have been\n\
                loaded are searched in order of most recently loaded to\n\
                first loaded.\n\
    LIST      A sequence of objects within \"{\" and \"}\", delimited by\n\
                spaces. LISTs can contain other lists.\n\
    STRING    A series of any characters within quotes or alphanumeric\n\
                characters preceded by a \"$\". Also, a string of alpha-\n\
                numeric characters standing alone is interpreted as a\n\
                STRING if it does not correspond to a variable name.\n\
    NUMBER    A number, treated as floating point double precision.\n\
\n" );
    HelpAdd( "relax", "\
\n\
    relax obj\n\
\n\
      UNIT                       _obj_\n\
\n\
Relaxes the selected atoms within _obj_.\n\
\n" );
    HelpAdd( "addH", "\
\n\
    addH obj\n\
\n\
      UNIT                       _obj_\n\
\n\
Add missing hydrogens and build external coordinates for _obj_.\n\
\n" );
    HelpAdd( "flip", "\
\n\
    flip obj\n\
\n\
      UNIT                       _obj_\n\
\n\
Flips the chirality of the selected atoms within _obj_.\n\
\n\
\n" );
    HelpAdd( "_cmd_options_", "\
The command-line options for starting tleap and xleap are:\n\
\n\
    -h         List these options.\n\
    -s         Ignore any leaprc startup file.\n\
    -I {dir}   Add {dir} to search path.\n\
    -f {file}  Source {file}.\n\
\n\
The tleap and xleap shell scripts automatically provide\n\
\n\
        -I$AMBERHOME/dat -I$AMBERHOME/dat/leap/lib -I$AMBERHOME/dat/leap/cmd\n\
where $AMBERHOME/dat contains 'parm.dat' force field files,\n\
      $AMBERHOME/dat/leap/lib contains residue libraries and\n\
      $AMBERHOME/dat/leap/cmd contains the default leaprc and other scripts.\n\
\n" );
}
